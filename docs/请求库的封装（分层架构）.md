# 请求库的封装

## 1. 简介

### 背景

虽然前端具有诸多成熟的请求库，但在实际项目开发中发现，它们很难完全契合实际的开发需求。

**axios**

axios 虽然很成熟，但它只是一个基础库，没有提供诸多的上层功能，比如：

1. 请求重试
2. 请求缓存
3. 请求幂等
4. 请求串行
5. 请求并发
6. ...

**VueRequest / SWR**

它们虽然提供的功能很多，但仍然存在诸多问题：

1. 与上层框架过度绑定导致开发场景受限，也无法提供统一的 API
2. 成熟度不够，issue 的回复也难以做到及时，存在一定风险
3. 它们没有聚合基础请求库，仍然需要手动整合

**除此之外更重要的是**

公共库不包含公司内部制定的协议规范，即便使用公共库，也必须针对它们做二次封装。

**综上，需要自行封装一套适配公司业务的前端请求库**

## 2. 技术栈与环境

- **包管理器:** pnpm (利用其 workspace 功能管理多包项目)
- **语言:** TypeScript (提供类型安全和接口定义能力)
- **构建工具:** tsup (用于构建 ESM 和 CommonJS 双格式输出)
- **核心依赖:**
  - `axios` (可选，作为底层请求实现)
  - `fetch` API (原生浏览器 API，无需额外依赖)
- **开发环境:** Node.js (LTS 版本), pnpm
- **演示工具:** Vite (用于浏览器演示应用)

## 3. 库结构的宏观设计（架构设计）

### 初始设计

![](https://cdn.nlark.com/yuque/0/2025/png/2894784/1756821951876-8d02c479-e059-43a2-a356-84a3a3e194cf.png)

整个库结构包含三层，从下往上依次是：

- `请求实现层（request-imp）`： 提供请求基本功能
- `request-core`： 提供网络上层控制，比如请求串行、请求并行、请求重试、请求防重等功能
- `request-bus`： 为请求绑定业务功能，该层接入公司内部协议规范和接口文档，向外提供业务接口 API

> 层是一种对代码结构的逻辑划分，在具体实现上可以有多种方式：
>
> - 每个层一个 monorepo 子包
> - 每个层一个子文件夹
> - ...

### **<font style="color:rgb(0, 0, 0);">优化设计**

在三层中，请求实现层的实现有多种方式：

- 基于`fetch`原生
- 基于`axios`等第三方库
- ...

<font style="color:rgb(51, 51, 51);">这种实现的多样性可能导致这一次层的不稳定，而`request-imp`<font style="color:rgb(51, 51, 51);">是基础层，它的不稳性会传导到上一层。

<font style="color:rgb(51, 51, 51);">所<font style="color:rgb(51, 51, 51);">以必须寻求一种方案来隔离这种不稳定性。

<font style="color:rgb(51, 51, 51);">我们可以基于 DIP（Dependence Inversion Principle，依赖倒置原则），彻底将`request-core`<font style="color:rgb(51, 51, 51);">和请求的实现解耦，而`typescript`<font style="color:rgb(51, 51, 51);">的类型系统让这一切的落地成为了可能。

<font style="color:rgb(51, 51, 51);">于是结构演变为：

![](https://cdn.nlark.com/yuque/0/2025/png/2894784/1756822612156-994a83ec-68d1-462c-b9d6-9e663293efaa.png)

下面是示意代码：

### `request-core`：**核心层**

核心层定义了请求者 (Requestor) 的抽象接口，并提供一个依赖此接口的高级功能类 RequestCore

```typescript
/**
 * @description 请求配置接口
 */
export interface RequestConfig {
  url: string
  method: 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH'
  data?: any
  headers?: Record<string, string>
  timeout?: number
}

/**
 * @description 请求者接口，定义了发送请求的标准化契约。
 * request-imp-* 模块需要实现此接口。
 */
export interface Requestor {
  request<T = any>(config: RequestConfig): Promise<T>
}

/**
 * @description 重试配置
 */
export interface RetryConfig {
  retries: number
  delay?: number
}

/**
 * @description 缓存配置
 */
export interface CacheConfig {
  ttl?: number // 缓存时间(ms)
  key?: string // 自定义缓存key
}

/**
 * @description 核心层，封装与具体实现无关的高级功能。
 */
export class RequestCore {
  private retryFeature: RetryFeature
  private cacheFeature: CacheFeature

  /**
   * 通过依赖注入接收一个实现了 Requestor 接口的实例。
   * @param requestor 具体的请求实现者。
   */
  constructor(private requestor: Requestor) {
    this.retryFeature = new RetryFeature(requestor)
    this.cacheFeature = new CacheFeature(requestor)
  }

  /**
   * 基础请求方法
   */
  async request<T>(config: RequestConfig): Promise<T> {
    return this.requestor.request<T>(config)
  }

  /**
   * GET 请求
   */
  async get<T>(url: string, config?: Partial<RequestConfig>): Promise<T> {
    return this.request<T>({ url, method: 'GET', ...config })
  }

  /**
   * POST 请求
   */
  async post<T>(url: string, data?: any, config?: Partial<RequestConfig>): Promise<T> {
    return this.request<T>({ url, method: 'POST', data, ...config })
  }

  /**
   * PUT 请求
   */
  async put<T>(url: string, data?: any, config?: Partial<RequestConfig>): Promise<T> {
    return this.request<T>({ url, method: 'PUT', data, ...config })
  }

  /**
   * DELETE 请求
   */
  async delete<T>(url: string, config?: Partial<RequestConfig>): Promise<T> {
    return this.request<T>({ url, method: 'DELETE', ...config })
  }

  /**
   * 带重试的请求
   */
  async requestWithRetry<T>(config: RequestConfig, retryConfig?: RetryConfig): Promise<T> {
    return this.retryFeature.requestWithRetry<T>(config, retryConfig)
  }

  /**
   * 带重试的 GET 请求
   */
  async getWithRetry<T>(url: string, retries: number = 3): Promise<T> {
    return this.requestWithRetry<T>({ url, method: 'GET' }, { retries })
  }

  /**
   * 带缓存的请求
   */
  async requestWithCache<T>(config: RequestConfig, cacheConfig?: CacheConfig): Promise<T> {
    return this.cacheFeature.requestWithCache<T>(config, cacheConfig)
  }

  /**
   * 带缓存的 GET 请求
   */
  async getWithCache<T>(url: string, cacheConfig?: CacheConfig): Promise<T> {
    return this.requestWithCache<T>({ url, method: 'GET' }, cacheConfig)
  }

  /**
   * 清除缓存
   */
  clearCache(key?: string): void {
    this.cacheFeature.clearCache(key)
  }
}
```

### `request-imp-*`**实现层**

这里提供两个具体的实现：request-axios-imp 和 request-fetch-imp。它们都实现了 request-core 中定义的 Requestor 接口

```typescript
import axios, { AxiosRequestConfig } from 'axios'
import { Requestor } from './request-core'

/**
 * @description 基于 Axios 的 Requestor 接口实现。
 */
export class AxiosRequestor implements Requestor {
  async request<T>(config: {
    url: string
    method: string
    data?: any
  }): Promise<T> {
    const axiosConfig: AxiosRequestConfig = {
      url: config.url,
      method: config.method as any,
      data: config.data,
    }
    console.log('[Imp] 使用 Axios 发送请求...')
    const response = await axios.request(axiosConfig)
    return response.data as T
  }
}
```

```typescript
import { Requestor } from './request-core'

/**
 * @description 基于 Fetch API 的 Requestor 接口实现。
 */
export class FetchRequestor implements Requestor {
  async request<T>(config: {
    url: string
    method: string
    data?: any
  }): Promise<T> {
    const fetchOptions: RequestInit = {
      method: config.method,
      headers: {
        'Content-Type': 'application/json',
      },
      body: config.data ? JSON.stringify(config.data) : null,
    }
    console.log('[Imp] 使用 Fetch API 发送请求...')
    const response = await fetch(config.url, fetchOptions)
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`)
    }
    return (await response.json()) as T
  }
}
```

### `request-bus`**业务层**

业务层提供了 RequestBus 类来管理 API 的注册和配置，支持动态切换底层实现。

```typescript
/**
 * @description 请求实现类型
 */
export type RequestImplementation = 'axios' | 'fetch'

/**
 * @description 配置类，负责选择并注入具体的实现
 */
export class RequestConfig {
  private static instance: RequestCore

  /**
   * 创建请求核心实例
   * @param implementation 选择的实现方式
   */
  static createRequestCore(implementation: RequestImplementation = 'axios'): RequestCore {
    if (!this.instance) {
      let requestor

      switch (implementation) {
        case 'axios':
          console.log('[Config] 使用 Axios 实现')
          requestor = new AxiosRequestor()
          break
        case 'fetch':
          console.log('[Config] 使用 Fetch 实现')
          requestor = new FetchRequestor()
          break
        default:
          throw new Error(`不支持的实现方式: ${implementation}`)
      }

      this.instance = new RequestCore(requestor)
    }

    return this.instance
  }

  /**
   * 获取当前实例
   */
  static getInstance(): RequestCore {
    if (!this.instance) {
      return this.createRequestCore()
    }
    return this.instance
  }

  /**
   * 重置实例（用于切换实现）
   */
  static reset(): void {
    this.instance = null as any
  }
}

/**
 * @description 业务层 API 集合
 */
class RequestBus {
  private apiMap: Map<string, any> = new Map()

  register(name: string, apiClass: any): any {
    if (!name) {
      throw new Error('name is required')
    }
    if (!apiClass) {
      throw new Error('apiClass is required')
    }
    if (this.apiMap.has(name)) {
      throw new Error(`${name} already registered`)
    }

    const apiInstance = new apiClass(RequestConfig.getInstance())
    this.apiMap.set(name, apiInstance)
    return apiInstance
  }

  /**
   * 切换请求实现
   * @param implementation 实现方式
   */
  switchImplementation(implementation: RequestImplementation): void {
    RequestConfig.reset()
    RequestConfig.createRequestCore(implementation)

    this.apiMap.forEach((api) => {
      api.requestCore = RequestConfig.getInstance()
    })
  }

  /**
   * 清除缓存
   * @param key 缓存键
   */
  clearCache(key?: string): void {
    RequestConfig.getInstance().clearCache(key)
  }

  /**
   * 清除所有缓存
   */
  clearAllCache(): void {
    RequestConfig.getInstance().clearCache()
  }
}

// 创建并导出单例
export const requestBus = new RequestBus()
```

### **使用示例 (浏览器演示)**

在浏览器环境中，我们可以动态注册和管理业务 API：

```javascript
// 注册用户 API
class UserApi {
  constructor(requestCore) {
    this.requestCore = requestCore
  }

  async getUserInfo(userId) {
    const url = `https://jsonplaceholder.typicode.com/users/${userId}`
    // 使用带重试的请求
    const userInfo = await this.requestCore.getWithRetry(url, 2)
    return {
      ...userInfo,
      fetchTime: new Date().toISOString(),
    }
  }

  async getUserList() {
    const url = 'https://jsonplaceholder.typicode.com/users'
    // 使用带缓存的请求，缓存 2 分钟
    return this.requestCore.getWithCache(url, { ttl: 2 * 60 * 1000 })
  }
}

// 注册到 RequestBus
const userApi = requestBus.register('user', UserApi)

// 使用 API
async function main() {
  try {
    console.log('--- 开始调用业务 API ---')
    const user = await userApi.getUserInfo('1')
    console.log('--- 业务 API 调用成功 ---')
    console.log('获取到的用户数据:', user)

    // 动态切换实现
    requestBus.switchImplementation('fetch')
    console.log('--- 已切换到 Fetch 实现 ---')
  } catch (error) {
    console.error('--- 业务 API 调用失败 ---')
    console.error('最终错误:', error)
  }
}

main()
```

### **架构图**

![](https://cdn.nlark.com/yuque/__mermaid_v3/c6640e7585132c65347eed6d694507f0.svg)

### **核心理念**

1. **分层架构**
   - `request-imp-*`: 提供具体的 HTTP 请求发送能力 (如 `request-imp-axios`, `request-imp-fetch`)。它们实现统一的 `Requestor` 接口
   - `request-core`: 核心层，定义 `Requestor` 接口，并基于此接口提供缓存、重试等与具体实现无关的高级功能。通过依赖注入接收 `request-imp` 的具体实现
   - `request-bus`: 业务层，提供 `RequestBus` 类来管理 API 注册，支持动态切换底层实现，并集成业务逻辑

2. **依赖倒置 (DIP)**
   - `request-core` 不直接依赖具体的实现 (axios/fetch)，而是依赖抽象的 `Requestor` 接口。具体实现 (`request-imp-*`) 反过来依赖（实现）这个接口。这使得底层实现可以轻松替换，而不影响核心层和业务层。

3. **当前实现的功能**
   - ✅ **请求重试**: 支持配置重试次数和延迟时间
   - ✅ **请求缓存**: 内存缓存，支持 TTL 和自定义缓存键
   - ✅ **基础请求方法**: GET, POST, PUT, DELETE
   - ✅ **类型安全**: 完整的 TypeScript 类型定义
   - ✅ **实现切换**: 运行时动态切换 axios/fetch 实现
   - ✅ **API 管理**: 通过 RequestBus 注册和管理业务 API

## 4. **项目结构图**

```plain
├── packages/                             // pnpm monorepo 的核心目录，存放所有子包
│   ├── request-core/                     // 核心层包：定义接口和实现与具体请求库无关的高级功能
│   │   ├── src/
│   │   │   ├── features/                 // 存放高级功能的具体实现
│   │   │   │   ├── cache.ts              // 功能：请求缓存（内存缓存）
│   │   │   │   └── retry.ts              // 功能：请求失败重试
│   │   │   ├── core.ts                   // RequestCore 类：组合所有 feature，提供统一的高级 API
│   │   │   ├── interface.ts              // 定义 Requestor 抽象接口，是依赖倒置的核心
│   │   │   └── index.ts                  // 包的入口文件，导出公共 API 和类型
│   │   ├── package.json                  // request-core 包的配置文件
│   │   └── tsconfig.json                 // TypeScript 配置文件
│   │
│   ├── request-imp-axios/                // 实现层包：基于 Axios
│   │   ├── src/
│   │   │   └── index.ts                  // 实现 Requestor 接口的 AxiosRequestor 类
│   │   ├── package.json                  // 依赖 axios 和 request-core
│   │   └── tsconfig.json
│   │
│   ├── request-imp-fetch/                // 实现层包：基于 Fetch API
│   │   ├── src/
│   │   │   └── index.ts                  // 实现 Requestor 接口的 FetchRequestor 类
│   │   ├── package.json                  // 依赖 request-core
│   │   └── tsconfig.json
│   │
│   └── request-bus/                      // 业务层包：组装和暴露给应用的最终 API
│       ├── src/
│       │   ├── config.ts                 // 配置类：选择并注入具体的 imp 实现 (axios/fetch)
│       │   └── index.ts                  // RequestBus 类：API 注册和管理，统一导出
│       ├── package.json                  // 依赖 request-core 和所有 request-imp-* 包
│       └── tsconfig.json
│
├── apps/                                 // 存放使用该请求库的示例应用或真实项目
│   └── demo-browser/                     // 浏览器演示应用
│       ├── api/                          // 业务 API 定义
│       │   ├── user.js                   // 用户相关 API
│       │   └── post.js                   // 文章相关 API
│       ├── index.html                    // HTML 页面
│       ├── main.js                       // 应用主文件，演示各种功能
│       ├── package.json                  // 依赖 request-bus
│       └── vite.config.js                // Vite 配置
│
├── .gitignore
├── package.json                          // Monorepo 根 package.json，管理 workspaces 和 scripts
├── pnpm-workspace.yaml                   // pnpm 的 workspace 配置文件，声明 packages 目录
└── tsconfig.json                         // Monorepo 根 TS 配置文件，为所有子包提供基础配置
```

## 5. 构建和发布

### 构建脚本

根目录下的构建脚本会自动构建所有包：

```bash
# 构建所有包
pnpm run build

# 构建浏览器演示应用
pnpm run build:browser

# 开发模式
pnpm run dev

# 启动浏览器演示
pnpm run demo:browser
```

### 包构建配置

每个包都配置了双格式输出：

- **ESM 格式**: `dist/index.js` - 现代浏览器和 Node.js 支持
- **CommonJS 格式**: `dist/cjs/index.js` - 兼容性更好的格式
- **类型定义**: `dist/index.d.ts` - TypeScript 类型支持

### 发布策略

1. **私有仓库发布**: 将核心包发布到私有 npm 仓库
2. **workspace 依赖**: 使用 `workspace:*` 在 monorepo 内部引用
3. **版本管理**: 通过 `package.json` 中的 version 字段管理版本

## 6. 未来扩展计划

虽然当前版本已经实现了核心功能，但根据文档的原始规划，还有以下功能可以后续添加：

### 🚧 计划中的功能

1. **请求并发控制**
   - 限制最大并发请求数
   - 请求队列管理
   - 优先级队列

2. **请求串行执行**
   - 保证请求顺序执行
   - 串行队列管理
   - 依赖关系处理

3. **请求幂等性**
   - 防止重复请求
   - 请求去重机制
   - 基于请求内容的哈希

4. **更丰富的缓存策略**
   - localStorage 缓存
   - IndexedDB 缓存
   - 缓存同步策略

5. **请求拦截器和响应拦截器**
   - 请求预处理
   - 响应后处理
   - 错误统一处理

### 🔧 扩展方式

在 `request-core/src/features/` 目录下添加新的功能模块：

```typescript
// 示例：并发控制功能
export class ConcurrencyFeature {
  constructor(private requestor: Requestor) {}

  async requestWithConcurrency<T>(
    config: RequestConfig,
    options: ConcurrencyOptions
  ): Promise<T> {
    // 实现并发控制逻辑
  }
}
```

然后在 `RequestCore` 类中集成新功能：

```typescript
export class RequestCore {
  private concurrencyFeature: ConcurrencyFeature

  constructor(requestor: Requestor) {
    this.concurrencyFeature = new ConcurrencyFeature(requestor)
  }

  async requestWithConcurrency<T>(
    config: RequestConfig,
    options?: ConcurrencyOptions
  ): Promise<T> {
    return this.concurrencyFeature.requestWithConcurrency<T>(config, options)
  }
}
```

这种模块化的设计使得新功能的添加非常便捷且不会影响现有代码。
