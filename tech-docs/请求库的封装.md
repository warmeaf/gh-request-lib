# 请求库的封装

## 面试

**请讲讲你是如何实现请求库的**

> 背景和痛点

在实际业务开发中，我发现现有的请求库存在几个关键问题：

首先是功能割裂问题。基础请求库如 axios 只提供基本的 HTTP 功能，缺乏业务层面的高级特性；而上层库如 SWR、VueRequest 虽然功能丰富，但与框架强绑定，无法跨项目复用。

其次是定制化需求。公司内部有统一的接口协议、鉴权机制和错误处理规范，现有库无法很好地支持这些定制需求。

最后是维护成本问题。不同项目使用不同的请求方案，缺乏统一标准，增加了维护难度。

基于这些痛点，我决定设计一套分层架构的通用请求库。

> 架构设计

我采用了三层分离的设计思路：

**实现层**：提供不同的底层实现，目前支持 axios 和 fetch 两种方式。这层专注于处理具体的网络请求，包括参数处理、超时控制、错误转换等。

**核心层**：实现各种业务特性，包括缓存管理、并发控制、重试逻辑、幂等处理、串行队列等。这层与具体实现解耦，通过接口约定与实现层交互。

**API 层**：对外提供统一的业务接口，封装公司内部协议和业务逻辑。

这种设计的好处是职责清晰、可扩展性强。比如将来需要支持新的底层实现，只需添加对应的实现包即可，不影响上层逻辑。

> 关键特性

在功能实现上，我重点关注了几个核心特性：

**智能缓存**：支持多种缓存策略，包括 TTL 过期、LRU 淘汰、手动失效等，有效减少重复请求。

**并发控制**：通过队列机制管理并发请求数量，防止浏览器连接限制和服务器压力过大。

**容错机制**：提供可配置的重试策略，包括指数退避、线性重试等，提升系统稳定性。

**幂等保证**：对于相同的请求，在短时间内只执行一次，避免重复提交。

这些特性都是可插拔的，开发者可以根据实际需求进行组合使用。

> 工程化实践

在工程实现上，我采用了 Monorepo 的管理方式，使用 pnpm workspace 管理多个包。每个包都有独立的测试覆盖率，整体测试覆盖率保持在 90% 以上。

同时，我建立了完善的类型系统，通过 TypeScript 提供强类型支持，减少运行时错误。

文档方面，除了 API 文档外，我还提供了丰富的示例代码和最佳实践指南，降低使用门槛。

> 实际效果

这套请求库在公司内部已经应用于多个项目，取得了不错的效果：

开发效率方面，统一的 API 和丰富的功能特性，让开发者能更专注于业务逻辑，减少了重复的基础设施建设。

系统稳定性方面，通过缓存、重试、并发控制等机制，显著提升了前端应用的健壮性。

维护成本方面，统一的技术栈和规范，降低了多项目维护的复杂度。

> 总结

整个实现过程中，我深刻体会到了分层设计和接口抽象的重要性。通过合理的架构设计，不仅解决了当前的业务问题，也为未来的扩展留下了空间。同时，完善的工程化实践确保了代码质量和项目的长期可维护性。
