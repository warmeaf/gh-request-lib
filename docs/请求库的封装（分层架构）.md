作者：Gemini-2.5-pro、@暖叶

---

## 1. 简介

### 背景

虽然前端具有诸多成熟的请求库，但在实际项目开发中发现，它们很难完全契合实际的开发需求。

**axios**

axios 虽然很成熟，但它只是一个基础库，没有提供诸多的上层功能，比如：

1. 请求重试
2. 请求缓存
3. 请求幂等
4. 请求串行
5. 请求并发
6. ...

**VueRequest / SWR**

它们虽然提供的功能很多，但仍然存在诸多问题：

1. 与上层框架过度绑定导致开发场景受限，也无法提供统一的 API
2. 成熟度不够，issue 的回复也难以做到及时，存在一定风险
3. 它们没有聚合基础请求库，仍然需要手动整合

**除此之外更重要的是**

公共库不包含公司内部制定的协议规范，即便使用公共库，也必须针对它们做二次封装。

**综上，需要自行封装一套适配公司业务的前端请求库**

## 2. 技术栈与环境

- **包管理器:** pnpm (利用其 workspace 功能管理多包项目)
- **语言:** TypeScript (提供类型安全和接口定义能力)
- **核心依赖 (可选):**
  - `axios` 或 `fetch` (作为底层请求实现)
  - `spark-md5` (用于请求哈希，实现幂等性)
- **开发环境:** Node.js (LTS 版本), pnpm

## 3. 库结构的宏观设计（架构设计）

### 初始设计

![](https://cdn.nlark.com/yuque/0/2025/png/2894784/1756821951876-8d02c479-e059-43a2-a356-84a3a3e194cf.png)

整个库结构包含三层，从下往上依次是：

- `请求实现层（request-imp）`： 提供请求基本功能
- `request-core`： 提供网络上层控制，比如请求串行、请求并行、请求重试、请求防重等功能
- `request-bus`： 为请求绑定业务功能，该层接入公司内部协议规范和接口文档，向外提供业务接口 API

> 层是一种对代码结构的逻辑划分，在具体实现上可以有多种方式：
>
> - 每个层一个 monorepo 子包
> - 每个层一个子文件夹
> - ...

### **<font style="color:rgb(0, 0, 0);">优化设计**

在三层中，请求实现层的实现有多种方式：

- 基于`fetch`原生
- 基于`axios`等第三方库
- ...

<font style="color:rgb(51, 51, 51);">这种实现的多样性可能导致这一次层的不稳定，而`request-imp`<font style="color:rgb(51, 51, 51);">是基础层，它的不稳性会传导到上一层。

<font style="color:rgb(51, 51, 51);">所<font style="color:rgb(51, 51, 51);">以必须寻求一种方案来隔离这种不稳定性。

<font style="color:rgb(51, 51, 51);">我们可以基于 DIP（Dependence Inversion Principle，依赖倒置原则），彻底将`request-core`<font style="color:rgb(51, 51, 51);">和请求的实现解耦，而`typescript`<font style="color:rgb(51, 51, 51);">的类型系统让这一切的落地成为了可能。

<font style="color:rgb(51, 51, 51);">于是结构演变为：

![](https://cdn.nlark.com/yuque/0/2025/png/2894784/1756822612156-994a83ec-68d1-462c-b9d6-9e663293efaa.png)

下面是示意代码：

### `request-core`：**核心层**

核心层定义了请求者 (Requestor) 的抽象接口，并提供一个依赖此接口的高级功能类 RequestCore

```typescript
/**
 * @description 请求者接口，定义了发送请求的标准化契约。
 * request-imp-* 模块需要实现此接口。
 */
export interface Requestor {
  request<T>(config: { url: string; method: string; data?: any }): Promise<T>
}

/**
 * @description 核心层，封装与具体实现无关的高级功能。
 */
export class RequestCore {
  private requestor: Requestor

  /**
   * 通过依赖注入接收一个实现了 Requestor 接口的实例。
   * @param requestor 具体的请求实现者。
   */
  constructor(requestor: Requestor) {
    this.requestor = requestor
  }

  /**
   * 一个示例高级功能：带重试的 GET 请求。
   * @param url 请求地址。
   * @param retries 重试次数。
   */
  public async getWithRetry<T>(url: string, retries: number = 3): Promise<T> {
    try {
      console.log(`[Core] 发起请求到: ${url}`)
      // 调用抽象接口，而不关心具体实现是 axios 还是 fetch
      return await this.requestor.request<T>({ url, method: 'GET' })
    } catch (error) {
      console.error(`[Core] 请求失败，剩余重试次数: ${retries - 1}`, error)
      if (retries > 1) {
        return this.getWithRetry<T>(url, retries - 1)
      }
      throw error
    }
  }

  // 此处可以添加更多高级功能，如缓存、幂等控制等...
}
```

### `request-imp-*`**实现层**

这里提供两个具体的实现：request-axios-imp 和 request-fetch-imp。它们都实现了 request-core 中定义的 Requestor 接口

```typescript
import axios, { AxiosRequestConfig } from 'axios'
import { Requestor } from './request-core'

/**
 * @description 基于 Axios 的 Requestor 接口实现。
 */
export class AxiosRequestor implements Requestor {
  async request<T>(config: {
    url: string
    method: string
    data?: any
  }): Promise<T> {
    const axiosConfig: AxiosRequestConfig = {
      url: config.url,
      method: config.method as any,
      data: config.data,
    }
    console.log('[Imp] 使用 Axios 发送请求...')
    const response = await axios.request(axiosConfig)
    return response.data as T
  }
}
```

```typescript
import { Requestor } from './request-core'

/**
 * @description 基于 Fetch API 的 Requestor 接口实现。
 */
export class FetchRequestor implements Requestor {
  async request<T>(config: {
    url: string
    method: string
    data?: any
  }): Promise<T> {
    const fetchOptions: RequestInit = {
      method: config.method,
      headers: {
        'Content-Type': 'application/json',
      },
      body: config.data ? JSON.stringify(config.data) : null,
    }
    console.log('[Imp] 使用 Fetch API 发送请求...')
    const response = await fetch(config.url, fetchOptions)
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`)
    }
    return (await response.json()) as T
  }
}
```

### `request-bus`**业务层**

业务层负责组装和暴露最终的 API。它会选择一个具体的 request-imp 实现，并将其注入到 request-core 中。

```typescript
import { RequestCore } from './request-core'
import { AxiosRequestor } from './request-axios-imp'
import { FetchRequestor } from './request-fetch-imp'

// --- 依赖注入和组装 ---

// 策略 1: 使用 Axios 作为实现
const axiosImp = new AxiosRequestor()
const coreWithAxios = new RequestCore(axiosImp)

// 策略 2: 使用 Fetch 作为实现 (可以轻松替换)
const fetchImp = new FetchRequestor()
const coreWithFetch = new RequestCore(fetchImp)

// 我们选择其中一个核心实例来构建业务 API
const currentCore = coreWithAxios // <== 在这里可以轻松切换实现

/**
 * @description 业务层 API，暴露给最终应用使用。
 * 它集成了公司特定的业务逻辑和协议规范。
 */
export const busApi = {
  /**
   * 获取用户信息（示例业务函数）。
   * @param userId 用户 ID。
   */
  getUserInfo: async (userId: string) => {
    // 假设公司协议规定用户信息的 URL 格式
    const url = `https://api.example.com/users/${userId}`
    console.log(`[Bus] 调用核心层获取用户信息: ${userId}`)

    // 调用 request-core 提供的通用方法
    // 可以在这里添加业务相关的逻辑，如数据转换、错误处理等
    const userInfo = await currentCore.getWithRetry<{
      id: string
      name: string
    }>(url)

    // 假设业务需要对返回的数据进行转换
    return {
      ...userInfo,
      fetchTime: new Date().toISOString(),
    }
  },

  // 此处可以有更多自动生成的或手写的业务 API 函数
}
```

### **使用示例 (main.ts)**

最后，应用程序只需要调用 request-bus 暴露的业务 API 即可，完全不需要关心底层的实现细节

```typescript
import { busApi } from './request-bus'

async function main() {
  try {
    console.log('--- 开始调用业务 API ---')
    // 应用层调用高度封装的业务方法
    const user = await busApi.getUserInfo('1')
    console.log('--- 业务 API 调用成功 ---')
    console.log('获取到的用户数据:', user)
  } catch (error) {
    console.error('--- 业务 API 调用失败 ---')
    console.error('最终错误:', error)
  }
}

main()
```

### **架构图**

![](https://cdn.nlark.com/yuque/__mermaid_v3/c6640e7585132c65347eed6d694507f0.svg)

### **核心理念**

1. **分层**
   - `request-imp-*`: 提供具体的 HTTP 请求发送能力 (如 `request-axios-imp`, `request-fetch-imp`)。它们实现统一的 `Requestor` 接口
   - `request-core`: 核心层，定义 `Requestor` 接口，并基于此接口提供缓存、重试、幂等、并发/串行控制等与具体实现无关的高级功能。通过依赖注入接收 `request-imp` 的具体实现
   - `request-bus`: 业务层，负责注入 `request-imp` 实现到 `request-core`，调用 `request-core` 提供的功能，集成公司特定业务逻辑和协议规范，并暴露最终给应用使用的 API 函数（部分可自动生成）
2. **依赖倒置 (DIP)**
   - `request-core` 不直接依赖具体的实现 (axios/fetch)，而是依赖抽象的 `Requestor` 接口。具体实现 (`request-imp-*`) 反过来依赖（实现）这个接口。这使得底层实现可以轻松替换，而不影响核心层和业务层。

## 4. **项目结构图**

```plain
├── packages/                             // pnpm monorepo 的核心目录，存放所有子包
│   ├── request-core/                     // 核心层包：定义接口和实现与具体请求库无关的高级功能
│   │   ├── src/
│   │   │   ├── features/                 // 存放高级功能的具体实现
│   │   │   │   ├── cache.ts              // 功能：请求缓存（如内存缓存、localStorage 缓存）
│   │   │   │   ├── concurrency.ts        // 功能：请求并发控制（如限制最大并发数）
│   │   │   │   ├── idempotency.ts        // 功能：请求幂等性（如防止重复提交）
│   │   │   │   ├── retry.ts              // 功能：请求失败重试
│   │   │   │   └── serial.ts             // 功能：请求串行执行（保证请求顺序）
│   │   │   ├── core.ts                   // RequestCore 类：组合所有 feature，提供统一的高级 API
│   │   │   ├── interface.ts              // 定义 Requestor 抽象接口，是依赖倒置的核心
│   │   │   └── index.ts                  // 包的入口文件，导出公共 API 和类型
│   │   ├── package.json                  // request-core 包的配置文件
│   │   └── tsconfig.json                 // TypeScript 配置文件
│   │
│   ├── request-imp-axios/                // 实现层包：基于 Axios
│   │   ├── src/
│   │   │   └── index.ts                  // 实现 Requestor 接口的 AxiosRequestor 类
│   │   ├── package.json                  // 依赖 axios 和 request-core
│   │   └── tsconfig.json
│   │
│   ├── request-imp-fetch/                // 实现层包：基于 Fetch API
│   │   ├── src/
│   │   │   └── index.ts                  // 实现 Requestor 接口的 FetchRequestor 类
│   │   ├── package.json                  // 依赖 request-core
│   │   └── tsconfig.json
│   │
│   └── request-bus/                      // 业务层包：组装和暴露给应用的最终 API
│       ├── src/
│       │   ├── apis/                     // 存放具体的业务 API 定义（可手动或自动生成）
│       │   │   ├── user.ts               // 示例：用户相关的 API
│       │   │   └── product.ts            // 示例：产品相关的 API
│       │   ├── config.ts                 // 配置文件：选择并注入具体的 imp 实现 (axios/fetch)
│       │   └── index.ts                  // 包的入口：组装所有业务 API 并统一导出
│       ├── package.json                  // 依赖 request-core 和某个 request-imp-* 包
│       └── tsconfig.json
│
├── apps/                                 // 存放使用该请求库的示例应用或真实项目
│   └── demo-app/                         // 一个使用 request-bus 的示例应用
│       ├── src/
│       │   └── main.ts                   // 应用主文件，演示如何调用 request-bus 导出的 API
│       ├── package.json                  // 依赖 request-bus
│       └── tsconfig.json
│
├── .gitignore
├── package.json                          // Monorepo 根 package.json，管理 workspaces 和 scripts
├── pnpm-workspace.yaml                   // pnpm 的 workspace 配置文件，声明 packages 目录
└── tsconfig.json                         // Monorepo 根 TS 配置文件，为所有子包提供基础配置
```

## 9. 构建和发布

1. **Build:** 使用 `pnpm -w run build`（假设根脚本会调用每个包中的构建脚本，例如使用 tsup 或 tsc）。如果复杂度增加，请确保通过 `tsconfig.json` 中的引用或使用 Turborepo/Nx 来保证正确的构建顺序。
2. **Publish:** 将相关的包（可能是 request-core、request-axios-imp、request-bus）发布到一个私有的 npm 仓库（如 Verdaccio、Nexus 或 GitHub Packages）。
